{
  "version": 3,
  "sources": ["../src/services/StreamingServiceDB.js", "../src/detectors/StreamingServiceDetector.js", "../src/content/MovieDetector.js", "../src/content/content-script.js"],
  "sourcesContent": ["// src/services/StreamingServiceDB.js\nexport class StreamingServiceDB {\n  constructor() {\n    this.dbName = 'movieTrackerDB';\n    this.version = 1;\n    this.db = null;\n    this.initPromise = this.init();\n  }\n\n  async init() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n\n      request.onerror = (event) => {\n        console.error(\"IndexedDB error:\", event.target.error);\n        reject(request.error);\n      };\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve(this.db);\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n\n        // Streaming services store\n        if (!db.objectStoreNames.contains('streamingServices')) {\n          const serviceStore = db.createObjectStore('streamingServices', {\n            keyPath: 'domain'\n          });\n          serviceStore.createIndex('name', 'name', { unique: false });\n          serviceStore.createIndex('category', 'category', { unique: false });\n          serviceStore.createIndex('addedDate', 'addedDate', { unique: false });\n        }\n\n        // User discovered services\n        if (!db.objectStoreNames.contains('discoveredServices')) {\n          const discoveredStore = db.createObjectStore('discoveredServices', {\n            keyPath: 'domain'\n          });\n          discoveredStore.createIndex('firstDetected', 'firstDetected', { unique: false });\n          discoveredStore.createIndex('lastSeen', 'lastSeen', { unique: false });\n          discoveredStore.createIndex('movieCount', 'movieCount', { unique: false });\n        }\n\n        // Movies/content cache\n        if (!db.objectStoreNames.contains('contentCache')) {\n          const contentStore = db.createObjectStore('contentCache', {\n            keyPath: 'id'\n          });\n          contentStore.createIndex('domain', 'domain', { unique: false });\n          contentStore.createIndex('title', 'title', { unique: false });\n          contentStore.createIndex('lastWatched', 'lastWatched', { unique: false });\n        }\n\n        // User preferences\n        if (!db.objectStoreNames.contains('userPreferences')) {\n          const prefStore = db.createObjectStore('userPreferences', {\n            keyPath: 'key'\n          });\n        }\n      };\n    });\n  }\n\n  async ensureReady() {\n    if (!this.db) {\n      // If initPromise is still pending, await it\n      await this.initPromise;\n    }\n    return this.db;\n  }\n\n  // Pre-populate with known streaming services\n  async seedKnownServices() {\n    await this.ensureReady();\n\n    const knownServices = [\n      {\n        domain: 'netflix.com',\n        name: 'Netflix',\n        category: 'premium',\n        patterns: ['/watch/', '/title/'],\n        selectors: {\n          title: '[data-uia=\"video-title\"], .video-title, h1',\n          duration: '[data-uia=\"video-duration\"]',\n          progress: '.progress-bar, .scrub-bar'\n        }\n      },\n      {\n        domain: 'hulu.com',\n        name: 'Hulu',\n        category: 'premium',\n        patterns: ['/watch/', '/series/'],\n        selectors: {\n          title: '.content-pack__title, h1',\n          duration: '.time-display__duration',\n          progress: '.progress-bar'\n        }\n      },\n      {\n        domain: 'amazon.com',\n        name: 'Prime Video',\n        category: 'premium',\n        patterns: ['/gp/video/detail/', '/dp/'],\n        selectors: {\n          title: '[data-automation-id=\"title\"], h1',\n          duration: '.duration',\n          progress: '.progress-bar'\n        }\n      },\n      {\n        domain: 'primevideo.com',\n        name: 'Prime Video',\n        category: 'premium',\n        patterns: ['/detail/', '/watch/'],\n        selectors: {\n          title: '[data-automation-id=\"title\"], h1',\n          duration: '.duration',\n          progress: '.progress-bar'\n        }\n      },\n      {\n        domain: 'disneyplus.com',\n        name: 'Disney+',\n        category: 'premium',\n        patterns: ['/video/', '/movies/', '/series/'],\n        selectors: {\n          title: '.title-field, h1',\n          duration: '.time-duration',\n          progress: '.progress-bar'\n        }\n      },\n      {\n        domain: 'hbomax.com',\n        name: 'HBO Max',\n        category: 'premium',\n        patterns: ['/feature/', '/series/', '/episode/'],\n        selectors: {\n          title: '[data-testid=\"title\"], h1',\n          duration: '.duration-label',\n          progress: '.scrubber-bar'\n        }\n      },\n      {\n        domain: 'crunchyroll.com',\n        name: 'Crunchyroll',\n        category: 'anime',\n        patterns: ['/watch/', '/series/'],\n        selectors: {\n          title: '.episode-title, .series-title, h1',\n          duration: '.time-total',\n          progress: '.progress-bar'\n        }\n      },\n      {\n        domain: 'funimation.com',\n        name: 'Funimation',\n        category: 'anime',\n        patterns: ['/shows/', '/v/'],\n        selectors: {\n          title: '.show-headline, h1',\n          duration: '.duration',\n          progress: '.vjs-progress-holder'\n        }\n      },\n      {\n        // CORRECTED YOUTUBE DOMAIN\n        domain: 'youtube.com',\n        name: 'YouTube',\n        category: 'free',\n        patterns: ['/watch?v='],\n        selectors: {\n          title: 'h1.title, .watch-main-col h1',\n          duration: '.ytp-time-duration',\n          progress: '.ytp-progress-bar'\n        }\n      },\n      {\n        domain: 'tubi.tv',\n        name: 'Tubi',\n        category: 'free',\n        patterns: ['/movies/', '/tv-shows/', '/watch/'],\n        selectors: {\n          title: '.watch-page-title, h1',\n          duration: '.duration-text',\n          progress: '.progress-bar'\n        }\n      },\n      {\n        domain: 'pluto.tv',\n        name: 'Pluto TV',\n        category: 'free',\n        patterns: ['/on-demand/', '/movies/', '/tv/'],\n        selectors: {\n          title: '.title, h1',\n          duration: '.duration',\n          progress: '.progress-bar'\n        }\n      },\n      {\n        domain: 'paramount.com',\n        name: 'Paramount+',\n        category: 'premium',\n        patterns: ['/shows/', '/movies/', '/video/'],\n        selectors: {\n          title: '.video-player__title, h1',\n          duration: '.video-player__duration',\n          progress: '.progress-bar'\n        }\n      },\n      {\n        domain: 'peacocktv.com',\n        name: 'Peacock',\n        category: 'freemium',\n        patterns: ['/watch/', '/movies/', '/tv/'],\n        selectors: {\n          title: '.title, h1',\n          duration: '.duration',\n          progress: '.progress-bar'\n        }\n      }\n    ];\n\n    const transaction = this.db.transaction(['streamingServices'], 'readwrite');\n    const store = transaction.objectStore('streamingServices');\n\n    for (const service of knownServices) {\n      service.addedDate = new Date();\n      service.isKnown = true;\n\n      try {\n        // Use .put() which will update if exists, or add if not.\n        // This ensures that if the DB already has some data, it gets updated.\n        await this.promisifyRequest(store.put(service));\n      } catch (error) {\n        console.error(`Error seeding service ${service.name}:`, error);\n      }\n    }\n  }\n\n  // Add a newly discovered streaming service\n  async addDiscoveredService(domain, metadata = {}) {\n    await this.ensureReady();\n\n    const service = {\n      domain: domain.replace(/^www\\./, ''), // Normalize domain\n      name: metadata.name || this.extractServiceName(domain),\n      category: metadata.category || 'unknown',\n      patterns: metadata.patterns || [],\n      selectors: metadata.selectors || {},\n      firstDetected: new Date(),\n      lastSeen: new Date(),\n      movieCount: 1,\n      isUserDiscovered: true,\n      confidence: metadata.confidence || 0.5\n    };\n\n    const transaction = this.db.transaction(['discoveredServices'], 'readwrite');\n    const store = transaction.objectStore('discoveredServices');\n\n    try {\n      // Check if already exists\n      const existing = await this.promisifyRequest(store.get(service.domain));\n\n      if (existing) {\n        // Update existing\n        existing.lastSeen = new Date();\n        existing.movieCount = (existing.movieCount || 0) + 1;\n        existing.confidence = Math.min(existing.confidence + 0.1, 1);\n\n        if (metadata.patterns) {\n          // Merge patterns, ensuring uniqueness\n          existing.patterns = [...new Set([...(existing.patterns || []), ...metadata.patterns])];\n        }\n        if (metadata.selectors) {\n           // Merge selectors, allowing new ones to overwrite old ones\n           existing.selectors = { ...(existing.selectors || {}), ...metadata.selectors };\n        }\n\n        await this.promisifyRequest(store.put(existing));\n        return existing;\n      } else {\n        // Add new\n        await this.promisifyRequest(store.add(service));\n        return service;\n      }\n    } catch (error) {\n      console.error('Error adding discovered service:', error);\n      throw error;\n    }\n  }\n\n  // Get streaming service info for a domain\n  async getServiceInfo(domain) {\n    await this.ensureReady();\n\n    const normalizedDomain = domain.replace(/^www\\./, '');\n\n    // Try known services first\n    const knownTransaction = this.db.transaction(['streamingServices'], 'readonly');\n    const knownStore = knownTransaction.objectStore('streamingServices');\n\n    // Try exact match first\n    let service = await this.promisifyRequest(knownStore.get(normalizedDomain));\n\n    if (!service) {\n      // Try partial match for subdomains\n      const allKnown = await this.promisifyRequest(knownStore.getAll());\n      service = allKnown.find(s =>\n        normalizedDomain.includes(s.domain) || s.domain.includes(normalizedDomain)\n      );\n    }\n\n    if (!service) {\n      // Try discovered services\n      const discoveredTransaction = this.db.transaction(['discoveredServices'], 'readonly');\n      const discoveredStore = discoveredTransaction.objectStore('discoveredServices');\n\n      service = await this.promisifyRequest(discoveredStore.get(normalizedDomain));\n\n      if (!service) {\n        const allDiscovered = await this.promisifyRequest(discoveredStore.getAll());\n        service = allDiscovered.find(s =>\n          normalizedDomain.includes(s.domain) || s.domain.includes(normalizedDomain)\n        );\n      }\n    }\n\n    return service;\n  }\n\n  // Fast domain lookup - returns boolean for quick detection\n  async isKnownStreamingDomain(domain) {\n    await this.ensureReady();\n\n    const normalizedDomain = domain.replace(/^www\\./, '');\n\n    try {\n      // Use getServiceInfo to check existence. It already handles both known and discovered.\n      const service = await this.getServiceInfo(normalizedDomain);\n      return !!service;\n    } catch (error) {\n      console.error('Error checking domain:', error);\n      return false;\n    }\n  }\n\n  // Get all streaming services (for management UI)\n  async getAllServices() {\n    await this.ensureReady();\n\n    const [known, discovered] = await Promise.all([\n      this.promisifyRequest(this.db.transaction(['streamingServices'], 'readonly').objectStore('streamingServices').getAll()),\n      this.promisifyRequest(this.db.transaction(['discoveredServices'], 'readonly').objectStore('discoveredServices').getAll())\n    ]);\n\n    return {\n      known,\n      discovered,\n      total: known.length + discovered.length\n    };\n  }\n\n  // Get all domains for fast lookup\n  async getAllDomains() {\n    await this.ensureReady();\n\n    const services = await this.getAllServices();\n    const domains = new Set();\n\n    services.known.forEach(service => domains.add(service.domain));\n    services.discovered.forEach(service => domains.add(service.domain));\n\n    return Array.from(domains);\n  }\n\n  // Cache movie/content data\n  async cacheContent(movieData) {\n    await this.ensureReady();\n\n    const content = {\n      id: `${movieData.serviceName}_${this.hashString(movieData.title)}_${Date.now()}`, // Use serviceName for ID\n      domain: movieData.domain, // Use domain, not 'site'\n      title: movieData.title,\n      url: movieData.url,\n      duration: movieData.duration,\n      currentTime: movieData.currentTime,\n      type: movieData.type, // Assuming type is passed\n      lastWatched: new Date(),\n      watchCount: 1\n    };\n\n    const transaction = this.db.transaction(['contentCache'], 'readwrite');\n    const store = transaction.objectStore('contentCache');\n\n    try {\n      // Check if content already exists based on title and domain (or more unique identifier)\n      // For simplicity, we add new entry for now, but a check could be added here\n      await this.promisifyRequest(store.add(content));\n    } catch (error) {\n      // This might fail if the ID is not truly unique.\n      // If 'id' is used as keyPath, and it's generated with Date.now(), it should be unique enough.\n      console.log('Content already cached (or ID collision):', content.title, error);\n    }\n  }\n\n  // Get recently watched content\n  async getRecentContent(limit = 50) {\n    await this.ensureReady();\n\n    const transaction = this.db.transaction(['contentCache'], 'readonly');\n    const store = transaction.objectStore('contentCache');\n    const index = store.index('lastWatched');\n\n    // Use openCursor for more control and to get a limited number of results in reverse order (most recent first)\n    const results = [];\n    const request = index.openCursor(null, 'prev'); // 'prev' for descending order\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = (event) => {\n        const cursor = event.target.result;\n        if (cursor && results.length < limit) {\n          // Filter by lastWatched date if needed, or just take the latest `limit`\n          // Example: const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n          // if (cursor.value.lastWatched > thirtyDaysAgo) {\n          //   results.push(cursor.value);\n          // }\n          results.push(cursor.value);\n          cursor.continue();\n        } else {\n          resolve(results);\n        }\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  // Analytics - get streaming service usage stats\n  async getServiceStats() {\n    await this.ensureReady();\n\n    const services = await this.getAllServices(); // Includes known and discovered\n    const content = await this.promisifyRequest(\n      this.db.transaction(['contentCache'], 'readonly').objectStore('contentCache').getAll()\n    );\n\n    const stats = {};\n\n    // Initialize stats with all known/discovered services to ensure they appear even if no content watched yet\n    [...services.known, ...services.discovered].forEach(s => {\n      if (!stats[s.domain]) {\n        stats[s.domain] = {\n          domain: s.domain,\n          name: s.name, // Include service name\n          category: s.category, // Include category\n          contentCount: 0,\n          totalWatchTime: 0, // In seconds\n          lastUsed: null\n        };\n      }\n    });\n\n    // Count content per service\n    content.forEach(item => {\n      if (stats[item.domain]) { // Only process if service exists in our list\n        stats[item.domain].contentCount++;\n        stats[item.domain].totalWatchTime += item.duration || 0;\n\n        if (!stats[item.domain].lastUsed || item.lastWatched > stats[item.domain].lastUsed) {\n          stats[item.domain].lastUsed = item.lastWatched;\n        }\n      }\n    });\n\n    return Object.values(stats).sort((a, b) => b.contentCount - a.contentCount);\n  }\n\n  // User preferences management\n  async setUserPreference(key, value) {\n    await this.ensureReady();\n\n    const transaction = this.db.transaction(['userPreferences'], 'readwrite');\n    const store = transaction.objectStore('userPreferences');\n\n    await this.promisifyRequest(store.put({ key, value, updatedAt: new Date() }));\n  }\n\n  async getUserPreference(key, defaultValue = null) {\n    await this.ensureReady();\n\n    const transaction = this.db.transaction(['userPreferences'], 'readonly');\n    const store = transaction.objectStore('userPreferences');\n\n    const result = await this.promisifyRequest(store.get(key));\n    return result ? result.value : defaultValue;\n  }\n\n  // Utility methods\n  extractServiceName(domain) {\n    // This is a basic extractor. For better results, you'd likely use a predefined map.\n    // Example: 'www.netflix.com' -> 'netflix.com' -> 'netflix' -> 'Netflix'\n    return domain\n      .replace(/^www\\./, '')\n      .split('.')[0]\n      .replace(/[-_]/g, ' ')\n      .replace(/\\b\\w/g, l => l.toUpperCase());\n  }\n\n  hashString(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return Math.abs(hash).toString(36);\n  }\n\n  promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  // Clean up old data\n  async cleanup(daysToKeep = 90) {\n    await this.ensureReady();\n\n    const cutoffDate = new Date(Date.now() - daysToKeep * 24 * 60 * 60 * 1000);\n\n    try {\n      // Clean old content cache\n      const contentTransaction = this.db.transaction(['contentCache'], 'readwrite');\n      const contentStore = contentTransaction.objectStore('contentCache');\n      const contentIndex = contentStore.index('lastWatched');\n\n      const request = contentIndex.openCursor(IDBKeyRange.upperBound(cutoffDate));\n      request.onsuccess = (event) => {\n        const cursor = event.target.result;\n        if (cursor) {\n          cursor.delete();\n          cursor.continue();\n        }\n      };\n      await this.promisifyRequest(request); // Await the completion of the cursor iteration\n\n      // Clean discovered services with low confidence and old dates\n      const discoveredTransaction = this.db.transaction(['discoveredServices'], 'readwrite');\n      const discoveredStore = discoveredTransaction.objectStore('discoveredServices');\n\n      const allDiscovered = await this.promisifyRequest(discoveredStore.getAll());\n\n      for (const service of allDiscovered) {\n        if (service.confidence < 0.3 && service.lastSeen < cutoffDate) {\n          await this.promisifyRequest(discoveredStore.delete(service.domain));\n        }\n      }\n\n      console.log(`Cleanup completed: removed content older than ${daysToKeep} days`);\n    } catch (error) {\n      console.error('Cleanup failed:', error);\n    }\n  }\n\n  // Export data for backup/analysis\n  async exportData() {\n    await this.ensureReady();\n\n    const [services, content, preferences] = await Promise.all([\n      this.getAllServices(),\n      this.promisifyRequest(this.db.transaction(['contentCache'], 'readonly').objectStore('contentCache').getAll()),\n      this.promisifyRequest(this.db.transaction(['userPreferences'], 'readonly').objectStore('userPreferences').getAll())\n    ]);\n\n    return {\n      timestamp: new Date().toISOString(),\n      version: this.version,\n      services,\n      content,\n      preferences\n    };\n  }\n\n  // Close database connection\n  close() {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n    }\n  }\n}", "// src/detectors/StreamingServiceDetector.js\nimport { StreamingServiceDB } from \"../services/StreamingServiceDB\";\n\nexport class StreamingServiceDetector {\n  constructor() {\n    this.db = new StreamingServiceDB();\n    this.domainCache = new Map();\n    this.cacheExpiry = 5 * 60 * 1000; // 5 minutes\n    this.initialized = false;\n\n    // Call init in constructor and handle async nature\n    // The constructor itself cannot be async, so we just kick off init.\n    // Consumers should await `initialized` or ensure `init` has completed.\n    this.init().then(() => {\n      console.log('StreamingServiceDetector fully initialized');\n    }).catch(error => {\n      console.error('Failed to fully initialize StreamingServiceDetector during construction:', error);\n    });\n  }\n\n  async init() {\n    if (this.initialized) return; // Prevent re-initialization\n\n    try {\n      await this.db.ensureReady();\n\n      // Seed known services on first run\n      const hasSeeded = await this.db.getUserPreference('hasSeededServices', false);\n      if (!hasSeeded) {\n        await this.db.seedKnownServices();\n        await this.db.setUserPreference('hasSeededServices', true);\n        console.log('Seeded known streaming services');\n      }\n\n      // Preload domains into cache for faster lookup\n      await this.preloadDomainCache();\n      this.initialized = true;\n\n      console.log('StreamingServiceDetector initialized');\n    } catch (error) {\n      console.error('Failed to initialize StreamingServiceDetector:', error);\n      // It's crucial to handle initialization failures, perhaps by setting initialized to false\n      // or throwing an error to indicate an unready state.\n      throw error; // Re-throw to propagate the error\n    }\n  }\n\n  async preloadDomainCache() {\n    try {\n      const domains = await this.db.getAllDomains();\n      const now = Date.now();\n\n      domains.forEach(domain => {\n        this.domainCache.set(domain, {\n          isStreaming: true,\n          timestamp: now\n        });\n      });\n\n      console.log(`Preloaded ${domains.length} streaming domains into cache`);\n    } catch (error) {\n      console.error('Failed to preload domain cache:', error);\n    }\n  }\n\n  // Fast domain detection using cache + fallback to DB\n  async isStreamingSite(url) {\n    if (!this.initialized) {\n      // Ensure initialization is complete before proceeding\n      await this.init();\n    }\n\n    try {\n      const domain = this.extractDomain(url);\n      const now = Date.now();\n\n      // Check cache first\n      const cached = this.domainCache.get(domain);\n      if (cached && (now - cached.timestamp) < this.cacheExpiry) {\n        return cached.isStreaming;\n      }\n\n      // Check database\n      const isStreaming = await this.db.isKnownStreamingDomain(domain);\n\n      // Update cache\n      this.domainCache.set(domain, {\n        isStreaming,\n        timestamp: now\n      });\n\n      return isStreaming;\n    } catch (error) {\n      console.error('Error checking if streaming site:', error);\n      return false;\n    }\n  }\n\n  // Get detailed service information\n  async getServiceInfo(url) {\n    if (!this.initialized) {\n      await this.init();\n    }\n\n    try {\n      const domain = this.extractDomain(url);\n      return await this.db.getServiceInfo(domain);\n    } catch (error) {\n      console.error('Error getting service info:', error);\n      return null;\n    }\n  }\n\n  // Detect if current page is likely a movie/video page\n  async detectMovieContext(url, documentContext = null) {\n    if (!this.initialized) {\n      await this.init();\n    }\n\n    const service = await this.getServiceInfo(url);\n    if (!service) return null;\n\n    const context = documentContext || document;\n    const movieInfo = {\n      url,\n      domain: service.domain,\n      serviceName: service.name,\n      category: service.category,\n      isMoviePage: false,\n      confidence: 0,\n      currentTime: 0, // Initialize\n      duration: 0 // Initialize\n    };\n\n    // Check URL patterns\n    if (service.patterns && service.patterns.length > 0) {\n      const hasMatchingPattern = service.patterns.some(pattern =>\n        url.includes(pattern)\n      );\n\n      if (hasMatchingPattern) {\n        movieInfo.isMoviePage = true;\n        movieInfo.confidence += 0.4;\n      }\n    }\n\n    // Check for video elements and get current time/duration\n    const videoElements = context.querySelectorAll('video');\n    if (videoElements.length > 0) {\n      const mainVideo = videoElements[0]; // Assuming the first video element is the main one\n      if (mainVideo) {\n        movieInfo.confidence += 0.3;\n        movieInfo.isMoviePage = true;\n        movieInfo.currentTime = mainVideo.currentTime || 0;\n        movieInfo.duration = mainVideo.duration && !isNaN(mainVideo.duration) && mainVideo.duration !== Infinity ? mainVideo.duration : 0; // Handle NaN or Infinity duration\n      }\n    }\n\n    // Check for title using service-specific selectors\n    if (service.selectors && service.selectors.title) {\n      const titleElement = context.querySelector(service.selectors.title);\n      if (titleElement && titleElement.textContent.trim()) {\n        movieInfo.title = titleElement.textContent.trim();\n        movieInfo.confidence += 0.2;\n        movieInfo.isMoviePage = true;\n      }\n    }\n\n    // Generic title fallback\n    if (!movieInfo.title) {\n      const genericTitleSelectors = [\n        'h1',\n        '[data-testid*=\"title\"]',\n        '.title',\n        '.video-title',\n        '.movie-title',\n        '.show-title'\n      ];\n\n      for (const selector of genericTitleSelectors) {\n        const element = context.querySelector(selector);\n        if (element && element.textContent.trim()) {\n          movieInfo.title = element.textContent.trim();\n          movieInfo.confidence += 0.1;\n          movieInfo.isMoviePage = true; // A title strongly suggests it's a content page\n          break;\n        }\n      }\n    }\n\n    // Check for duration/progress indicators (if not already from video element)\n    if (!movieInfo.duration && service.selectors && service.selectors.duration) {\n      const durationElement = context.querySelector(service.selectors.duration);\n      if (durationElement) {\n        // Attempt to parse duration from text if it's in a specific format (e.g., \"HH:MM:SS\" or \"MM:SS\")\n        const durationText = durationElement.textContent.trim();\n        const parts = durationText.split(':').map(Number);\n        let durationInSeconds = 0;\n        if (parts.length === 3) { // HH:MM:SS\n          durationInSeconds = parts[0] * 3600 + parts[1] * 60 + parts[2];\n        } else if (parts.length === 2) { // MM:SS\n          durationInSeconds = parts[0] * 60 + parts[1];\n        } else if (!isNaN(Number(durationText))) { // Just a number (e.g., minutes)\n          durationInSeconds = Number(durationText) * 60; // Assume minutes if only a number\n        }\n\n        if (durationInSeconds > 0) {\n          movieInfo.duration = durationInSeconds;\n          movieInfo.confidence += 0.1;\n          movieInfo.isMoviePage = true; // Duration also suggests a content page\n        }\n      }\n    }\n\n    // Return movieInfo only if confidence is sufficient and it's identified as a movie page\n    return movieInfo.confidence > 0.3 && movieInfo.isMoviePage ? movieInfo : null;\n  }\n\n  // Add a new streaming service discovered by user interaction\n  async addUserDiscoveredService(url, metadata = {}) {\n    if (!this.initialized) {\n      await this.init();\n    }\n\n    try {\n      const domain = this.extractDomain(url);\n\n      // Analyze current page for patterns\n      const patterns = this.analyzeUrlPatterns(url);\n      const selectors = this.analyzePageSelectors();\n\n      const serviceMetadata = {\n        ...metadata,\n        patterns: [...(metadata.patterns || []), ...patterns],\n        selectors: { ...(metadata.selectors || {}), ...selectors },\n        confidence: 0.7 // User-discovered has higher initial confidence\n      };\n\n      const service = await this.db.addDiscoveredService(domain, serviceMetadata);\n\n      // Update cache\n      this.domainCache.set(domain, {\n        isStreaming: true,\n        timestamp: Date.now()\n      });\n\n      console.log('Added user-discovered streaming service:', service);\n      return service;\n    } catch (error) {\n      console.error('Error adding user-discovered service:', error);\n      throw error;\n    }\n  }\n\n  // Analyze URL to extract potential patterns\n  analyzeUrlPatterns(url) {\n    const patterns = [];\n    try {\n      const urlObj = new URL(url);\n      const pathname = urlObj.pathname;\n\n      // Common video page patterns\n      const commonPatterns = [\n        '/watch/',\n        '/video/',\n        '/movie/',\n        '/series/',\n        '/show/',\n        '/episode/',\n        '/stream/',\n        '/play/'\n      ];\n\n      commonPatterns.forEach(pattern => {\n        if (pathname.includes(pattern)) {\n          patterns.push(pattern);\n        }\n      });\n\n      // Extract dynamic patterns (like /v/[id] or /watch?v=)\n      if (pathname.match(/\\/v\\/\\w+/)) {\n        patterns.push('/v/');\n      }\n\n      if (urlObj.search.includes('v=')) {\n        patterns.push('/watch?v=');\n      }\n    } catch (error) {\n      console.error('Error analyzing URL patterns:', error);\n    }\n    return patterns;\n  }\n\n  // Analyze page to find potential selectors\n  analyzePageSelectors() {\n    const selectors = {};\n\n    // Find title selectors\n    const titleCandidates = [\n      'h1',\n      '[data-testid*=\"title\"]',\n      '.title',\n      '.video-title',\n      '.movie-title',\n      '.show-title' // Added for completeness\n    ];\n\n    for (const selector of titleCandidates) {\n      const element = document.querySelector(selector);\n      if (element && element.textContent.trim().length > 3) { // Ensure a meaningful title\n        selectors.title = selector;\n        break;\n      }\n    }\n\n    // Find video elements (selector can be 'video' itself)\n    const videos = document.querySelectorAll('video');\n    if (videos.length > 0) {\n      selectors.video = 'video';\n    }\n\n    // Find duration selectors\n    const durationCandidates = [\n      '.duration',\n      '.time-total',\n      '.video-duration',\n      '[data-testid*=\"duration\"]',\n      '.current-time + .separator + .total-time' // Common pattern for \"0:00 / 1:23:45\"\n    ];\n\n    for (const selector of durationCandidates) {\n      const element = document.querySelector(selector);\n      if (element && element.textContent.match(/\\d+:\\d+/)) { // Match common time formats\n        selectors.duration = selector;\n        break;\n      }\n    }\n\n    return selectors;\n  }\n\n  // Extract domain from URL\n  extractDomain(url) {\n    try {\n      const urlObj = new URL(url);\n      return urlObj.hostname.replace(/^www\\./, '');\n    } catch (error) {\n      console.error('Invalid URL:', url);\n      return '';\n    }\n  }\n\n  // Get statistics about discovered services\n  async getDiscoveryStats() {\n    if (!this.initialized) {\n      await this.init();\n    }\n\n    try {\n      // Assuming db.getAllServices() and db.getServiceStats() exist and return expected data\n      // Note: The original code assumes a `total` property on `services` which isn't standard\n      // for an array. Adjusting to `services.length`.\n      const allServices = await this.db.getAllServices(); // Assuming this returns an array\n      const stats = await this.db.getServiceStats(); // Assuming this returns array for mostUsedServices\n\n      const knownServices = allServices.filter(s => s.isKnownService); // Assuming a property to differentiate\n      const discoveredServices = allServices.filter(s => !s.isKnownService);\n\n      return {\n        totalServices: allServices.length,\n        knownServices: knownServices.length,\n        discoveredServices: discoveredServices.length,\n        mostUsedServices: stats.slice(0, 10), // Assuming stats is an array of service objects\n        cacheSize: this.domainCache.size\n      };\n    } catch (error) {\n      console.error('Error getting discovery stats:', error);\n      return null;\n    }\n  }\n\n  // Clean up cache and old data\n  async cleanup() {\n    try {\n      // Clear expired cache entries\n      const now = Date.now();\n      for (const [domain, data] of this.domainCache.entries()) {\n        if (now - data.timestamp > this.cacheExpiry) {\n          this.domainCache.delete(domain);\n        }\n      }\n\n      // Clean up database (assuming this.db.cleanup() exists)\n      await this.db.cleanup();\n\n      console.log('StreamingServiceDetector cleanup completed');\n    } catch (error) {\n      console.error('Cleanup failed:', error);\n    }\n  }\n\n  // Export service data for analysis\n  async exportServices() {\n    try {\n      return await this.db.exportData();\n    } catch (error) {\n      console.error('Export failed:', error);\n      return null;\n    }\n  }\n}", "import {StreamingServiceDetector} from '../detectors/StreamingServiceDetector'\n\nclass MovieDetector {\n  constructor() {\n    this.detector = new StreamingServiceDetector();\n    this.currentMovie = null;\n    this.observers = new Map();\n    this.detectionInterval = null;\n    this.isActive = false;\n    this.initialized = false;\n  }\n\n  async init() {\n    if (this.initialized) return;\n    \n    try {\n      // Ensure the detector is fully initialized\n      await this.detector.init();\n\n      const currentUrl = window.location.href;\n      const isStreamingSite = await this.detector.isStreamingSite(currentUrl);\n\n      if (!isStreamingSite) {\n        console.log('Movie Tracker: Site not recognized as streaming');\n        this.initialized = true;\n        return;\n      }\n\n      const serviceInfo = await this.detector.getServiceInfo(currentUrl);\n      console.log('Movie Tracker: Streaming site detected:', serviceInfo);\n\n      this.isActive = true;\n      this.initialized = true;\n      this.startDetection();\n    } catch (error) {\n      console.error('Movie Tracker: Initialization error:', error);\n      this.initialized = true; // Set to true even on error to prevent infinite retries\n    }\n  }\n\n  // Add method to check if ready\n  isReady() {\n    return this.initialized;\n  }\n\n  startDetection() {\n    this.detectMovie(); // initial detection\n    this.detectionInterval = setInterval(() => this.detectMovie(), 3000);\n    this.setupObservers();\n  }\n\n  async detectMovie() {\n    if (!this.isActive || !this.initialized) return;\n\n    try {\n      const context = await this.detector.detectMovieContext(window.location.href, document);\n\n      if (context && context.title) {\n        const isNewMovie =\n          !this.currentMovie ||\n          this.currentMovie.title !== context.title ||\n          this.currentMovie.url !== context.url;\n\n        if (isNewMovie) {\n          this.currentMovie = context;\n          this.onMovieDetected(context);\n        } else {\n          this.updateProgress(context);\n        }\n      } else if (this.currentMovie) {\n        console.log('Movie Tracker: Movie no longer detected on page.');\n        this.currentMovie = null;\n      }\n    } catch (err) {\n      console.error('Movie Tracker: Detection error:', err);\n    }\n  }\n\n  updateProgress(movie) {\n    if (!this.currentMovie) return;\n\n    const changed =\n      movie.currentTime !== this.currentMovie.currentTime ||\n      movie.duration !== this.currentMovie.duration;\n\n    if (changed) {\n      this.currentMovie.currentTime = movie.currentTime;\n      this.currentMovie.duration = movie.duration;\n      this.currentMovie.timestamp = Date.now();\n\n      this.onProgressUpdate(this.currentMovie);\n    }\n  }\n\n  setupObservers() {\n    this.observers.forEach(o => o.disconnect());\n    this.observers.clear();\n\n    const observeVideoElements = () => {\n      const videos = document.querySelectorAll('video');\n      videos.forEach(video => {\n        video.removeEventListener('timeupdate', this.detectMovieBound);\n        video.removeEventListener('durationchange', this.detectMovieBound);\n        video.removeEventListener('play', this.detectMovieBound);\n        video.removeEventListener('pause', this.detectMovieBound);\n        video.removeEventListener('ended', this.detectMovieBound);\n\n        video.addEventListener('timeupdate', this.detectMovieBound);\n        video.addEventListener('durationchange', this.detectMovieBound);\n        video.addEventListener('play', this.detectMovieBound);\n        video.addEventListener('pause', this.detectMovieBound);\n        video.addEventListener('ended', this.detectMovieBound);\n      });\n    };\n\n    this.detectMovieBound = this.detectMovie.bind(this);\n    observeVideoElements();\n\n    const videoDomObserver = new MutationObserver((mutations) => {\n      let videosChanged = false;\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList' && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {\n          const containsVideo = (nodes) => Array.from(nodes).some(node => node.nodeName === 'VIDEO' || node.querySelector?.('video'));\n          if (containsVideo(mutation.addedNodes) || containsVideo(mutation.removedNodes)) {\n            videosChanged = true;\n            break;\n          }\n        }\n      }\n      if (videosChanged) {\n        console.log('Movie Tracker: Video DOM changed, re-observing videos.');\n        observeVideoElements();\n        this.detectMovieBound();\n      }\n    });\n\n    videoDomObserver.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n    this.observers.set('videoDom', videoDomObserver);\n\n    const titleObserver = new MutationObserver(() => this.detectMovieBound());\n    titleObserver.observe(document.head, {\n      childList: true,\n      subtree: true,\n      characterData: true\n    });\n    this.observers.set('title', titleObserver);\n  }\n\n  onMovieDetected(movie) {\n    console.log('Movie Tracker: Movie detected:', movie);\n\n    const overlay = document.createElement('div');\n    overlay.className = 'movie-tracker-overlay visible';\n    overlay.innerHTML = `\n      <div class=\"title\">${movie.title}</div>\n      <div class=\"info\">${this.formatDuration(movie.duration)} \u2022 ${movie.serviceName}</div>\n    `;\n    document.body.appendChild(overlay);\n    setTimeout(() => overlay.remove(), 5000);\n\n    this.sendToBackground('MOVIE_DETECTED', movie);\n\n    window.dispatchEvent(\n      new CustomEvent('movieDetected', { detail: movie })\n    );\n  }\n\n  onProgressUpdate(movie) {\n    console.log('Movie Tracker: Progress updated:', movie);\n    this.sendToBackground('PROGRESS_UPDATE', movie);\n\n    window.dispatchEvent(\n      new CustomEvent('progressUpdate', { detail: movie })\n    );\n  }\n\n  formatDuration(seconds) {\n    if (isNaN(seconds) || seconds === 0) return 'N/A';\n    const h = Math.floor(seconds / 3600);\n    const m = Math.floor((seconds % 3600) / 60);\n    const s = Math.floor(seconds % 60);\n\n    const pad = (num) => num.toString().padStart(2, '0');\n\n    if (h > 0) {\n      return `${h}:${pad(m)}:${pad(s)}`;\n    }\n    return `${m}:${pad(s)}`;\n  }\n\n  sendToBackground(type, data) {\n    if (chrome?.runtime?.sendMessage) {\n      chrome.runtime\n        .sendMessage({ type, data, timestamp: Date.now() })\n        .catch((e) => {\n          console.error('Movie Tracker: Background send failed', e);\n        });\n    } else {\n      console.warn('Movie Tracker: chrome.runtime.sendMessage not available');\n    }\n  }\n\n  destroy() {\n    this.isActive = false;\n    this.initialized = false;\n    if (this.detectionInterval) clearInterval(this.detectionInterval);\n    this.observers.forEach((o) => o.disconnect());\n    this.observers.clear();\n    \n    const videos = document.querySelectorAll('video');\n    videos.forEach(video => {\n        video.removeEventListener('timeupdate', this.detectMovieBound);\n        video.removeEventListener('durationchange', this.detectMovieBound);\n        video.removeEventListener('play', this.detectMovieBound);\n        video.removeEventListener('pause', this.detectMovieBound);\n        video.removeEventListener('ended', this.detectMovieBound);\n    });\n    console.log('Movie Tracker: Detector destroyed');\n  }\n}\n\nexport default MovieDetector;", "// content.js\nimport MovieDetector from \"./MovieDetector\";\nimport './content.css';\n\nconsole.log('Movie Tracker: Content script loaded');\n\nlet movieDetectorInstance = null;\nlet lastUrl = window.location.href;\n\nconst initializeMovieDetector = async () => {\n  // Destroy existing instance if it exists\n  if (movieDetectorInstance) {\n    movieDetectorInstance.destroy();\n    movieDetectorInstance = null;\n    console.log('Movie Tracker: Previous detector destroyed.');\n  }\n\n  try {\n    // Create and initialize a new detector\n    movieDetectorInstance = new MovieDetector();\n    \n    // Wait for initialization to complete\n    await movieDetectorInstance.init();\n    \n    // Expose globally for popup access\n    window.movieDetector = {\n      instance: movieDetectorInstance,\n      smartDetector: {\n        extractMovieInfo: () => {\n          // Return current movie data or attempt detection\n          if (movieDetectorInstance.currentMovie) {\n            return movieDetectorInstance.currentMovie;\n          }\n          \n          // If no current movie, try immediate detection\n          const url = window.location.href;\n          return movieDetectorInstance.detector.detectMovieContext(url, document);\n        }\n      }\n    };\n    \n    console.log('Movie Tracker: New detector initialized and exposed globally.');\n  } catch (error) {\n    console.error('Movie Tracker: Failed to initialize detector:', error);\n  }\n};\n\n// Initial setup on page load\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initializeMovieDetector);\n} else {\n  initializeMovieDetector();\n}\n\n// Observe URL changes for SPAs\nnew MutationObserver(() => {\n  const currentUrl = window.location.href;\n  if (currentUrl !== lastUrl) {\n    lastUrl = currentUrl;\n    console.log('Movie Tracker: URL changed to', currentUrl);\n    initializeMovieDetector();\n  }\n}).observe(document, {\n  subtree: true,\n  childList: true,\n  attributes: true,\n  attributeFilter: ['href', 'src', 'data-url']\n});"],
  "mappings": "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",
  "names": []
}
